import { Inject, Injectable } from '@angular/core';
import { ScannedActionsSubject, } from '@ngrx/store';
import { Observable } from 'rxjs';
import { filter } from 'rxjs/operators';
export class Actions extends Observable {
    constructor(source) {
        super();
        if (source) {
            this.source = source;
        }
    }
    lift(operator) {
        const observable = new Actions();
        observable.source = this;
        observable.operator = operator;
        return observable;
    }
}
Actions.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Actions.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] }] }
];
/**
 * `ofType` filters an Observable of `Actions` into an Observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 */
export function ofType(...allowedTypes) {
    return filter((action) => allowedTypes.some((typeOrActionCreator) => {
        if (typeof typeOrActionCreator === 'string') {
            // Comparing the string to type
            return typeOrActionCreator === action.type;
        }
        // We are filtering by ActionCreator
        return typeOrActionCreator.type === action.type;
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL21vZHVsZXMvZWZmZWN0cy9zcmMvYWN0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBSUwscUJBQXFCLEdBQ3RCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxVQUFVLEVBQThCLE1BQU0sTUFBTSxDQUFDO0FBQzlELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd4QyxNQUFNLE9BQU8sT0FBb0IsU0FBUSxVQUFhO0lBQ3BELFlBQTJDLE1BQXNCO1FBQy9ELEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxNQUFNLEVBQUU7WUFDVixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztTQUN0QjtJQUNILENBQUM7SUFFRCxJQUFJLENBQUksUUFBd0I7UUFDOUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUssQ0FBQztRQUNwQyxVQUFVLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUN6QixVQUFVLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUMvQixPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDOzs7WUFmRixVQUFVOzs7O1lBSEYsVUFBVSx1QkFLSixNQUFNLFNBQUMscUJBQXFCOztBQXFGM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQ3BCLEdBQUcsWUFBNEQ7SUFFL0QsT0FBTyxNQUFNLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUMvQixZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsbUJBQW1CLEVBQUUsRUFBRTtRQUN4QyxJQUFJLE9BQU8sbUJBQW1CLEtBQUssUUFBUSxFQUFFO1lBQzNDLCtCQUErQjtZQUMvQixPQUFPLG1CQUFtQixLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDNUM7UUFFRCxvQ0FBb0M7UUFDcEMsT0FBTyxtQkFBbUIsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQztJQUNsRCxDQUFDLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQWN0aW9uLFxuICBBY3Rpb25DcmVhdG9yLFxuICBDcmVhdG9yLFxuICBTY2FubmVkQWN0aW9uc1N1YmplY3QsXG59IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIE9wZXJhdG9yRnVuY3Rpb24sIE9wZXJhdG9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBY3Rpb25zPFYgPSBBY3Rpb24+IGV4dGVuZHMgT2JzZXJ2YWJsZTxWPiB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoU2Nhbm5lZEFjdGlvbnNTdWJqZWN0KSBzb3VyY2U/OiBPYnNlcnZhYmxlPFY+KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgfVxuXG4gIGxpZnQ8Uj4ob3BlcmF0b3I6IE9wZXJhdG9yPFYsIFI+KTogT2JzZXJ2YWJsZTxSPiB7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZSA9IG5ldyBBY3Rpb25zPFI+KCk7XG4gICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgfVxufVxuXG4vLyBNb2R1bGUtcHJpdmF0ZSBoZWxwZXIgdHlwZVxudHlwZSBBY3Rpb25FeHRyYWN0b3I8XG4gIFQgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIEVcbj4gPSBUIGV4dGVuZHMgc3RyaW5nID8gRSA6IFJldHVyblR5cGU8RXh0cmFjdDxULCBBQz4+O1xuXG5leHBvcnQgZnVuY3Rpb24gb2ZUeXBlPFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPltdLFxuICBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLFxuICBWID0gUmV0dXJuVHlwZTxBQ1tudW1iZXJdPlxuPiguLi5hbGxvd2VkVHlwZXM6IEFDKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB9PixcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBUMSBleHRlbmRzIHN0cmluZyA/IEUgOiBSZXR1cm5UeXBlPEV4dHJhY3Q8VDEsIEFDPj5cbj4odDE6IFQxKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHsgdHlwZTogVDEgfCBUMiB9PixcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiwgQUMsIEU+XG4+KHQxOiBUMSwgdDI6IFQyKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHsgdHlwZTogVDEgfCBUMiB8IFQzIH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDMgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyIHwgVDMsIEFDLCBFPlxuPih0MTogVDEsIHQyOiBUMiwgdDM6IFQzKTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHsgdHlwZTogVDEgfCBUMiB8IFQzIHwgVDQgfT4sXG4gIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LFxuICBUMSBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMiBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMyBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUNCBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLFxuICBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIgfCBUMyB8IFQ0LCBBQywgRT5cbj4odDE6IFQxLCB0MjogVDIsIHQzOiBUMywgdDQ6IFQ0KTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHsgdHlwZTogVDEgfCBUMiB8IFQzIHwgVDQgfCBUNSB9PixcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQzIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQ0IGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQ1IGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiB8IFQzIHwgVDQgfCBUNSwgQUMsIEU+XG4+KHQxOiBUMSwgdDI6IFQyLCB0MzogVDMsIHQ0OiBUNCwgdDU6IFQ1KTogT3BlcmF0b3JGdW5jdGlvbjxVLCBWPjtcbi8qKlxuICogRmFsbGJhY2sgZm9yIG1vcmUgdGhhbiA1IGFyZ3VtZW50cy5cbiAqIFRoZXJlIGlzIG5vIGluZmVyZW5jZSwgc28gdGhlIHJldHVybiB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSBpbnB1dCAtXG4gKiBPYnNlcnZhYmxlPEFjdGlvbj4uXG4gKlxuICogV2UgcHJvdmlkZSBhIHR5cGUgcGFyYW1ldGVyLCBldmVuIHRob3VnaCBUUyB3aWxsIG5vdCBpbmZlciBpdCBmcm9tIHRoZVxuICogYXJndW1lbnRzLCB0byBwcmVzZXJ2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBuZ3J4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZUeXBlPFYgZXh0ZW5kcyBBY3Rpb24+KFxuICAuLi5hbGxvd2VkVHlwZXM6IEFycmF5PHN0cmluZyB8IEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPj5cbik6IE9wZXJhdG9yRnVuY3Rpb248QWN0aW9uLCBWPjtcbi8qKlxuICogYG9mVHlwZWAgZmlsdGVycyBhbiBPYnNlcnZhYmxlIG9mIGBBY3Rpb25zYCBpbnRvIGFuIE9ic2VydmFibGUgb2YgdGhlIGFjdGlvbnNcbiAqIHdob3NlIHR5cGUgc3RyaW5ncyBhcmUgcGFzc2VkIHRvIGl0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgYWN0aW9uc2AgaGFzIHR5cGUgYEFjdGlvbnM8QWRkaXRpb25BY3Rpb258U3Vic3RyYWN0aW9uQWN0aW9uPmAsIGFuZFxuICogdGhlIHR5cGUgb2YgdGhlIGBBZGRpdGlvbmAgYWN0aW9uIGlzIGBhZGRgLCB0aGVuXG4gKiBgYWN0aW9ucy5waXBlKG9mVHlwZSgnYWRkJykpYCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlPEFkZGl0aW9uQWN0aW9uPmAuXG4gKlxuICogUHJvcGVybHkgdHlwaW5nIHRoaXMgZnVuY3Rpb24gaXMgaGFyZCBhbmQgcmVxdWlyZXMgc29tZSBhZHZhbmNlZCBUUyB0cmlja3NcbiAqIGJlbG93LlxuICpcbiAqIFR5cGUgbmFycm93aW5nIGF1dG9tYXRpY2FsbHkgd29ya3MsIGFzIGxvbmcgYXMgeW91ciBgYWN0aW9uc2Agb2JqZWN0XG4gKiBzdGFydHMgd2l0aCBhIGBBY3Rpb25zPFNvbWVVbmlvbk9mQWN0aW9ucz5gIGluc3RlYWQgb2YgZ2VuZXJpYyBgQWN0aW9uc2AuXG4gKlxuICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3aGVuIG9uZSBwYXNzZXMgYSBzaW5nbGUgdHlwZSBhcmd1bWVudFxuICogYG9mVHlwZTxUPignc29tZXRoaW5nJylgIHRoZSByZXN1bHQgaXMgYW4gYE9ic2VydmFibGU8VD5gLiBOb3RlLCB0aGF0IGBUYFxuICogY29tcGxldGVseSBvdmVycmlkZXMgYW55IHBvc3NpYmxlIGluZmVyZW5jZSBmcm9tICdzb21ldGhpbmcnLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIGZvciB1bmtub3duICdhY3Rpb25zOiBBY3Rpb25zJyB0aGVzZSB0eXBlcyB3aWxsIHByb2R1Y2VcbiAqICdPYnNlcnZhYmxlPG5ldmVyPicuIEluIHN1Y2ggY2FzZXMgb25lIGhhcyB0byBtYW51YWxseSBzZXQgdGhlIGdlbmVyaWMgdHlwZVxuICogbGlrZSBgYWN0aW9ucy5vZlR5cGU8QWRkaXRpb25BY3Rpb24+KCdhZGQnKWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGUoXG4gIC4uLmFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nIHwgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+PlxuKTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIEFjdGlvbj4ge1xuICByZXR1cm4gZmlsdGVyKChhY3Rpb246IEFjdGlvbikgPT5cbiAgICBhbGxvd2VkVHlwZXMuc29tZSgodHlwZU9yQWN0aW9uQ3JlYXRvcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDb21wYXJpbmcgdGhlIHN0cmluZyB0byB0eXBlXG4gICAgICAgIHJldHVybiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBhY3Rpb24udHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIGZpbHRlcmluZyBieSBBY3Rpb25DcmVhdG9yXG4gICAgICByZXR1cm4gdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlID09PSBhY3Rpb24udHlwZTtcbiAgICB9KVxuICApO1xufVxuIl19